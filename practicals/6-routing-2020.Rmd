---
title: "Routing"
subtitle: '<br/>Practical'
author: "Malcolm Morgan"
date: 'University of Leeds, `r Sys.Date()`<br/><img class="img-footer" alt="" src="http://www.stephanehess.me.uk/images/picture3.png">'
output: html_document
bibliography: ../references.bib
---

## Setting Up (10 minutes)

We will use [ITS Go](https://itsleeds.github.io/go/) to do an easy setup of your computer.

```{r, eval=FALSE, message=FALSE, warning=FALSE}
source("https://git.io/JvGjF")
```

If that does not work the packages we will be using are:

* sf
* tidyverse
* tmap
* pct
* stplanr
* dodgr
* opentripplanner
* ITSleeds/geofabrik

## Using OpenTripPlanner to get routes

We have setup the Multi-modal routing service OpenTripPlanner for West Yorkshire. Try typing the URL shown during the session into your broswer. You should see somthign like this:

```{r, echo = FALSE, fig.align='center', fig.cap="\\label{fig:otpgui}OTP Web GUI"}
knitr::include_graphics("otp_screenshot.png")
```

Exercise 1: Play with the web interface, finding different types of routes. What strengths/limitations can you find?

### Connecting to OpenTripPlanner

To allow R to connect to the OpenTripPlanner server we will use the `opentripplanner` package and the function `otp_connect`. In this example I have saved the hostname of the server as a variaible callled "robinIP" in my Renviron file by using `usethis::edit_r_environ()` 

However you can also just set it manually.

```{r, eval=TRUE, message=FALSE, warning=FALSE}
library(sf)
library(tidyverse)
library(stplanr)
library(opentripplanner)
otpcon <- otp_connect(hostname = Sys.getenv("robinIP"), port = 8080)
```

If you have connected sucessfully, then you should get a message "Router exists"

To get some routes we will start by importing some data we have used previosly.

```{r, message=FALSE}
u = "https://github.com/ITSLeeds/TDS/releases/download/0.1/desire_lines.geojson"
download.file(u, "desire_lines.geojson")
desire_lines = read_sf("desire_lines.geojson")
```

This dataset has desire lines, but most routing packages need start and end points, so we will extract the points from the lines using the `line2df` function. An then select the top 3 desire lines.

```{r, message=FALSE}
desire = bind_cols(desire_lines, line2df(desire_lines))
desire = st_drop_geometry(desire)
desire_top = top_n(desire, 3, all)
```

To find the routes for these desire lines.

```{r, message=FALSE, eval=TRUE}
routes_top = otp_plan(otpcon,
                      fromPlace = as.matrix(desire_top[,c("fx","fy")]),
                      toPlace = as.matrix(desire_top[,c("tx","ty")]),
                      mode = "CAR")

```

We can plot those routes using the `tmap` package

```{r, message=FALSE, eval=TRUE, echo=FALSE}
library(tmap)
tmap_mode("view")
qtm(routes_top)
```

To save overloading the server I have pre-generated some extra routes.

```{r, message=FALSE, eval=FALSE, echo=FALSE}
routes_drive = otp_plan(otpcon,
                      fromPlace = as.matrix(desire[,c("fx","fy")]),
                      toPlace = as.matrix(desire[,c("tx","ty")]),
                      fromID = desire$geo_code1,
                      toID = desire$geo_code2,
                      mode = "CAR",
                      ncore = 4)



routes_transit = otp_plan(otpcon,
                      fromPlace = as.matrix(desire[,c("fx","fy")]),
                      toPlace = as.matrix(desire[,c("tx","ty")]),
                      fromID = desire$geo_code1,
                      toID = desire$geo_code2,
                      mode = c("TRANSIT","WALK"),
                      maxWalkDistance = 1500,
                      ncore = 4)
write_sf(routes_drive,"driving_routes.gpkg")
write_sf(routes_transit,"transit_routes.gpkg")
```

```{r, message=FALSE, eval=TRUE, echo=TRUE}
routes_drive = read_sf("https://github.com/ITSLeeds/TDS/releases/download/0.20.1/driving_routes.gpkg")
routes_transit = read_sf("https://github.com/ITSLeeds/TDS/releases/download/0.20.1/transit_routes.gpkg")
```

Exercise: Examine these two new datasets `routes_drive` and `routes_transit` plot them on a map, what useful information do they contain what is missing?


Finally lets join the routes to the original desire dataset.

```{r, message=FALSE, eval=FALSE, echo=FALSE}
desire_drive = left_join(desire, routes_drive, by = c("geo_code1" = "fromPlace", 
                                                      "geo_code2" = "toPlace"))
```

Note that some of the desire lines do not have a route. This is usually because the start or end point is too far from the road.

Exercise: How many routes are missing for each mode? How could you improve this method so there were no missing routes?

## Line Merging

Notice that `routes_transit` has returned separate rows for each mode (WALK, RAIL). Notice the `route_option` column shows that some routes have multiple options.

Let's suppose you want a single line for each route.

Exercies: Filter the `routes_transit` to contain only one route option per origin-destination pair.
Bonus Exercies: DO the above but make sure you always select the fastest option.

```{r, eval=TRUE, message=FALSE, echo=FALSE}
routes_transit <- routes_transit[routes_transit$route_option == 1,]
```

Now We will group the separate parts of the routes toghter.

```{r, eval=TRUE, message=FALSE}

routes_transit_group <- routes_transit %>%
  dplyr::group_by(fromPlace, toPlace) %>%
  dplyr::summarise(duration = sum(duration),
                   startTime = min(startTime),
                   endTime = max(endTime),
                   distance = sum(distance))

```

We now have a single row but instead of a `LINESTRING` we now have a mix of `MULTILINESTRING` and `LINESTRING`, we can convert to a linestring by using `st_line_merge()`. Note how the different columns where summarised.

First we must separate out the `MULTILINESTRING` and `LINESTRING`

```{r, eval=FALSE}
routes_transit_group_ml <- routes_transit_group[st_geometry_type(routes_transit_group) == "MULTILINESTRING", ]
routes_transit_group <- routes_transit_group[st_geometry_type(routes_transit_group) != "MULTILINESTRING", ]
routes_transit_group_ml <- st_line_merge(routes_transit_group_ml)
routes_transit_group <- rbind(routes_transit_group, routes_transit_group_ml)
```


## Network Analysis (dodgr) (20 minutes)

We will now look to analyse the road network using `dodgr`. Fist lets find the distances between all our centroids for a cyclist. `dodgr_dists` returns a matrix of distances in km, note the speed of using dodgr to find 64 distances compared to using a routing service. `dodgr` works well for these type of calcualtion, but cannot do public transport timetables.

```{r, eval=TRUE, warning=FALSE}
library(geofabrik)
library(dodgr)
roads <- get_geofabrik("west-yorkshire")
roads <- roads[!is.na(roads$highway),]
roads <- roads[,c( "osm_id","name","highway","maxspeed","oneway","lanes","bridge","foot","bicycle","lit","footway")]


streetnet <- weight_streetnet(roads)
distances <- dodgr::dodgr_dists(streetnet, as.matrix(flow2[,3:4]), as.matrix(flow2[,5:6]))
colnames(distances) <- flow2$code_d
rownames(distances) <- flow2$code_o
distances
```

`dodgr` can also aggregate flows across a network, this allows you to find the total number of cyclists on a particular road.

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Make a flow count matrix
flow3 <- data.frame(geo_code1 = rep(flow$geo_code1, times = nrow(flow)),
                    geo_code2 = rep(flow$geo_code2, each = nrow(flow)))
flow3 <- dplyr::left_join(flow3, flow[,c("geo_code1","geo_code2","bicycle")], by = c("geo_code1","geo_code2"))
flow3$bicycle[is.na(flow3$bicycle)] <- 0
flow3 <- matrix(flow3$bicycle, nrow = nrow(flow), byrow = TRUE)
flow3 
# Aggregate the flows across the road network
streetnet <- dodgr::dodgr_flows_aggregate(streetnet, as.matrix(flow2[,3:4]), as.matrix(flow2[,5:6]), flows = flow3)
```

To visualise the results we must convert the `dodgr` graph back to an `sf` object.

```{r, eval=TRUE, warning=FALSE}
# Make a flow count matrix
roads_flow <- dodgr::dodgr_to_sfc(streetnet)
roads_flow <- sf::st_sf(cbind(roads_flow$dat, roads_flow$geometry))
roads_flow <- roads_flow[roads_flow$flow > 0,]
qtm(roads_flow, lines.col = "flow", lines.lwd = 3)
```

**Exercises**
The method above has introduced some double counting can you find and fix the flaw?

Try re-downloading the whole flow dataset and producing route network for the whole of the Isle of Wight.

## Network Analysis (igraph) (20 minutes)

`igraph` is a package for analysing all types of network, we will use `igraph` to identify any bottlenecks in the road network. We will do this by calculating the betweenness centrality of the major road network. The will provide a measure of the most "important" roads in the network. As this calculation takes a long time we will only do it for the major roads.

```{r, eval=TRUE, warning=FALSE}
# subset to main roads
roads <- roads[roads$highway %in% c("primary","secondary","tertiary"),]

streetnet <- dodgr::weight_streetnet(roads) #39074
streetnet_cont <- dodgr::dodgr_contract_graph(streetnet) # Simplify the street network
# convert to igraph and calualte betweeness
streetnet_cont$graph$flow <- 0 # fix as bug with weight_streetnet
graph <- dodgr::dodgr_to_igraph(streetnet_cont$graph)
betweenness <- igraph::edge_betweenness(graph, directed = F) # This will take a while

# Transfer Value from contracted graph to main graph
streetnet_cont$graph$between <- betweenness
graph_join <- dplyr::left_join(streetnet_cont$edge_map, streetnet_cont$graph[,c("edge_id","between")], by = c("edge_new" = "edge_id"))
graph_join$edge_old <- as.integer(graph_join$edge_old)
streetnet <- dplyr::left_join(streetnet, graph_join, by = c("edge_id" = "edge_old"))
roads_betweeness <- dodgr::dodgr_to_sfc(streetnet)
roads_betweeness <- sf::st_sf(cbind(roads_betweeness$dat, roads_betweeness$geometry))
qtm(roads_betweeness, lines.col = "between", lines.lwd = 3)
```

## Bonus Material (30 minutes)

Open Trip Planner (OTP) is a powerful multimodal route planner written in JAVA. The `opentripplanner` package allows you to set up and use the OTP from R.

**Exercises**

Work though the vignettes [Getting Started](https://github.com/ITSLeeds/opentripplanner/blob/master/vignettes/getting_started.Rmd) and [Advanced Features](https://github.com/ITSLeeds/opentripplanner/blob/master/vignettes/advanced_features.Rmd)

